# -*- coding: utf-8 -*-
"""PZ_faces.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DGK-d62WAF-i7t0j_t_CaviR22lU5oVh
"""

import matplotlib.image as image
import matplotlib.pyplot as plt
import numpy as np
import zipfile as zp
import os
import pandas as pd
import torch
from tqdm.notebook import tqdm

from torchvision import datasets, transforms
from torch.utils.data import DataLoader
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
from sklearn.model_selection import train_test_split

#while True:pass

from google.colab import drive
drive.mount('/content/drive')

"""# Labeling"""

Faces_Dir = '/content/drive/MyDrive/Projekt_Zespołowy/crop_part1'

img_paths =[] #for multiple pictures
age_labels = []
gender_labels =[]

for filename in tqdm(os.listdir(Faces_Dir)):
  img_path = os.path.join(Faces_Dir, filename)
  tmp = filename.split('_')
  age = int(tmp[0])
  gender = int(tmp[1])

  age_labels.append(age)
  gender_labels.append(gender)
  img_paths.append(img_path)

data_frame = pd.DataFrame()
data_frame['image'], data_frame['age'], data_frame['gender']= img_paths, age_labels, gender_labels

data_frame.head

from torch.utils import data
#maping gender labels
gender_dictionary = {0:'Male', 1:'Female'}

"""# Data INFO :)"""

from PIL import Image
ex_image = Image.open(data_frame['image'][6840])
plt.imshow(ex_image)

"""Cell for testing:"""

#image importing using torchvision

#reading images as greyscale torch tensor
ex_im = torchvision.io.read_image(data_frame['image'][1000],
                                  torchvision.io.ImageReadMode.GRAY)
ex_im.reshape(200,200).shape
im = np.array(ex_im)
im = im.reshape(200,200)
plt.imshow(im)

ex1_im = Image.open((data_frame['image'][1000]))
ex1_im = np.array(ex1_im).mean(axis=2)
ex1_im.shape

"""# Sets creation"""

def images_featuring(images):
  features = []
  for num in range(images.size):
    img = torchvision.io.read_image(images[num],
                                    torchvision.io.ImageReadMode.GRAY)
    img = img.reshape((200, 200), 1)
    img = img.numpy()
    features.append(img)
  features = np.array(features)
  features = features.reshape(len(features), 200, 200, 1)

  return features

#selecting device
device = "cuda" if torch.cuda.is_available() else "cpu"
device

X = images_featuring(data_frame['image'])

#normalizing pix. to 0-1
X = X/255.0

X = torch.Tensor(X).view(-1,200,200)
X[0]

y_gender = np.array(data_frame['gender'])
#y_gender = torch.Tensor(y_gender)
#[0,1,0,1,0]->[[1,0],[0,1]]
y_age = np.array(data_frame['age'])
#y_age = torch.Tensor(y_age)

import seaborn as sns
sns.countplot(data_frame['gender'])
y_gender.dtype

"""# **Gender Estimation**"""

X_train, X_test, y_train, y_test = train_test_split(X, y_gender,
                                                    test_size = 0.2,
                                                    random_state = 4)
y_train[:10]

y_train_hot = []
# y = y_train

for i in y_train:
  y_train_hot.append(np.eye(2)[i])

y_train_hot[:10]

#model class for gender prediction
class ConvolutionalNetwork(nn.Module):
    # def __init__(self):
    #     super().__init__()
    #     self.conv1 = nn.Conv2d(1, 60, 3, 1)
    #     self.conv2 = nn.Conv2d(60, 100, 3, 1)
    #     self.conv3 = nn.Conv2d(100, 200, 3, 1)
    #     self.fc1 = nn.Linear(23*23*200, 2000) #(((((200-2)/2)-2))/2)-2))/2) = 23,..
    #     self.fc2 = nn.Linear(2000, 400)
    #     self.fc3 = nn.Linear(400,2)

    # def forward(self, X):
    #     X = F.relu(self.conv1(X))
    #     X = F.max_pool2d(X, 2, 2)
    #     X = F.relu(self.conv2(X))
    #     X = F.max_pool2d(X, 2, 2)
    #     X = F.relu(self.conv3(X))
    #     X = F.max_pool2d(X, 2, 2)
    #     X = X.view(-1, 23*23*200)
    #     X = F.relu(self.fc1(X))
    #     X = F.relu(self.fc2(X))
    #     X = self.fc3(X)
    #     return F.sigmoid(X)

# dla 4 warstw conv
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 30, 3, 1)
        self.conv2 = nn.Conv2d(30, 60, 3, 1)
        self.conv3 = nn.Conv2d(60, 100, 3, 1)
        self.conv4 = nn.Conv2d(100,150, 3, 1)
        self.fc1 = nn.Linear(10*10*150, 2000) #(((((200-2)/2)-2))/2)-2))/2) = 23,.. (4->10)
        self.fc2 = nn.Linear(2000, 300)
        self.fc3 = nn.Linear(300,2) #8-liczba klas wieków

    def forward(self, X):
        X = F.relu(self.conv1(X))
        X = F.max_pool2d(X, 2, 2)
        X = F.relu(self.conv2(X))
        X = F.max_pool2d(X, 2, 2)
        X = F.relu(self.conv3(X))
        X = F.max_pool2d(X, 2, 2)
        X = F.relu(self.conv4(X))
        X = F.max_pool2d(X, 2, 2)
        X = X.view(-1, 10*10*150)
        X = F.relu(self.fc1(X))
        X = F.relu(self.fc2(X))
        X = self.fc3(X)
        return F.sigmoid(X)
        #softmax(X, dim=1)

model = ConvolutionalNetwork().to(device)
model

loss_function = nn.BCELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

"""## *Train* and *Test*"""

BATCH_SIZE = 80
EPOCHS = 10

y_train_hot = torch.Tensor(y_train_hot)

for epoch in range(EPOCHS):
    for i in tqdm(range(0, len(X_train), BATCH_SIZE)): # from 0, to the len of x, stepping BATCH_SIZE at a time. [:50] ..for now just to dev
        #print(f"{i}:{i+BATCH_SIZE}")
        batch_X = X_train[i:i+BATCH_SIZE].view(-1, 1, 200, 200).to(device)
        batch_y = y_train_hot[i:i+BATCH_SIZE].to(device)
        #print(batch_y.dtype)
        #batch_y = batch_y.type(torch.LongTensor)
        #target = torch.nn.functional.one_hot(batch_y,num_classes=2)
        model.zero_grad()

        outputs = model(batch_X)
        #print(batch_y, outputs)
        loss = loss_function(outputs, batch_y)
        loss.backward()
        optimizer.step()    # Does the update
        #if (i%100 == 0):
         #     print(f"Batch: {int((i/BATCH_SIZE))}. Loss: {loss}")

    print(f"Epoch: {epoch+1}. Loss: {loss}")

correct = 0
total = 0
with torch.no_grad():
    for i in tqdm(range(len(X_test))):
        real_class = y_test[i]
        net_out = model(X_test[i].to(device).view(-1, 1, 200, 200))[0]  # returns a list, 
        predicted_class = torch.argmax(net_out)
        #if(predicted_class!=0):
         # print(predicted_class, real_class)
        if predicted_class == real_class:
            correct += 1
        total += 1
print("Accuracy: ", round(correct/total, 3))

"""# **Age Estimation**"""

from math import tan
#Setting age ranges
# 8-15, 15-20, 20-27, 27-35, 35-45, 45-55, 55-65, 65-..
y_age_range = y_age
count = 0
for idx, age in np.ndenumerate(y_age_range):
  if age <= 8:
    y_age_range[idx] = -1
    count += 1
  elif age > 8 and age <= 15:
    y_age_range[idx] = 0
  elif age > 15 and age <= 20:
    y_age_range[idx] = 1
  elif age > 20 and age <= 27:
    y_age_range[idx] = 2
  elif age > 27 and age <= 35:
    y_age_range[idx] = 3
  elif age > 35 and age <= 45:
    y_age_range[idx] = 4
  elif age > 45 and age <= 55:
    y_age_range[idx] = 5
  elif age > 55 and age <= 65:
    y_age_range[idx] = 6
  elif age> 65:
    y_age_range[idx] = 7

count

#usuwanie wieku z indx = -1 ->(0-8)
y_age_range_ = y_age_range
indexes_out = []
a = 0
for idx, num in np.ndenumerate(y_age_range_):
  if num == -1:
    indexes_out.append(idx)
len(indexes_out)

#usuwanie indeksów z y
y_age_no_out = np.delete(y_age_range_, indexes_out)

#usuwanie tych samych indeksów z x
X_ = X
X_no_out = np.delete(X_, indexes_out, 0)
X_no_out.shape

import seaborn as sns
sns.countplot(y_age_no_out)

Xage_train, Xage_test, yage_train, yage_test = train_test_split(X_no_out, y_age_no_out,
                                                    test_size = 0.2,
                                                    random_state = 4)
yage_train[:10]

#one hot encoding
yage_train_hot = []

for i in yage_train:
  yage_train_hot.append(np.eye(8)[i])

yage_train_hot[:10]

#model class for age prediction
class ConvolutionalNetwork_age(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 3, 1)
        self.conv2 = nn.Conv2d(20, 50, 3, 1)
        self.conv3 = nn.Conv2d(50, 70, 3, 1)
        self.conv4 = nn.Conv2d(70,90, 3, 1)
        self.fc1 = nn.Linear(10*10*90, 1000) #(((((200-2)/2)-2))/2)-2))/2) = 23,.. (4->10)
        self.fc2 = nn.Linear(1000, 100)
        self.fc3 = nn.Linear(100,8) #8-liczba klas wieków

    def forward(self, X):
        X = F.relu(self.conv1(X))
        X = F.max_pool2d(X, 2, 2)
        X = F.relu(self.conv2(X))
        X = F.max_pool2d(X, 2, 2)
        X = F.relu(self.conv3(X))
        X = F.max_pool2d(X, 2, 2)
        X = F.relu(self.conv4(X))
        X = F.max_pool2d(X, 2, 2)
        X = X.view(-1, 10*10*90)
        X = F.relu(self.fc1(X))
        X = F.relu(self.fc2(X))
        X = self.fc3(X)
        return F.softmax(X, dim=1)

model_age = ConvolutionalNetwork_age().to(device)
model_age

loss_function_age = nn.CrossEntropyLoss()
optimizer_age = torch.optim.Adam(model_age.parameters(), lr=0.001)

BATCH_SIZE = 80
EPOCHS = 15

yage_train_hot = torch.Tensor(yage_train_hot)

for epoch in range(EPOCHS):
    for i in tqdm(range(0, len(Xage_train), BATCH_SIZE)): # from 0, to the len of x, stepping BATCH_SIZE at a time. [:50] ..for now just to dev
        #print(f"{i}:{i+BATCH_SIZE}")
        batch_Xage = Xage_train[i:i+BATCH_SIZE].view(-1, 1, 200, 200).to(device)
        batch_yage = yage_train_hot[i:i+BATCH_SIZE].to(device)
        model_age.zero_grad()

        outputs_age = model_age(batch_Xage)
        #print(batch_y, outputs)
        loss = loss_function_age(outputs_age, batch_yage)
        loss.backward()
        optimizer_age.step()    # Does the update
        #if (i%100 == 0):
         #     print(f"Batch: {int((i/BATCH_SIZE))}. Loss: {loss}")

    print(f"Epoch: {epoch+1}. Loss: {loss}")

correct = 0
total = 0
with torch.no_grad():
    for i in tqdm(range(len(Xage_test))):
        real_class = yage_test[i]
        net_out = model_age(Xage_test[i].to(device).view(-1, 1, 200, 200))[0]  # returns a list, 
        predicted_class = torch.argmax(net_out)
        #if(predicted_class!=0):
         # print(predicted_class, real_class)
        if predicted_class == real_class:
            correct += 1
        total += 1
print("Accuracy: ", round(correct/total, 3))

!nvidia-smi